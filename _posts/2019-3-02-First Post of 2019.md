---
layout: post
title: "Blog #5: First Post"
featured-img: Algorithms-and-Data-Structures-Made-Easy-in-Java

---

## First Post of 2019
It is a new year for 


## Binary Search Tree Code Example

As BST knowledge has enhanced over the years, there should be



```
#include <iostream>
#include <cstdlib>
#include <math.h>

using namespace std;

class BinarySearchTree
{

                private:

                class node

{

                public:

                  node* left;

                  node* right;

                  node* parent;

                  int key;

                  string data;

};

    public:

      node* root;

      BinarySearchTree()

{

        root = NULL;

}

            bool isEmpty() const { return root == NULL; }

            void inOrderTree(node*);

            void preOrderWalk(node*);

            void postOrderWalk(node*);

            void treeInsert(int );
            
            //void treeDeletion(int );

            int maxValueNode(node*);

};

void BinarySearchTree::treeInsert(int d)

{
                    node* z = new node();

                    z->key = d;

                    z->left = NULL;

                    z->right = NULL;

                    node* y = NULL;

                    node* x = root;

                    node* parent = NULL;

                    while (x != NULL)

                    {

                                y = x;

                                if (z->key < x->key)

                                      x = x->left;

                                else

                                      x = x->right;

                    }

                    parent = y;

                    if (y == NULL)

                            root = z;

                    else if (z->key < y->key)

                           y->left = z;

                    else

                            y->right = z;

}

void BinarySearchTree::inOrderTree(node* x)
{

if (x != NULL)
{

        if (x->left)
            inOrderTree(x->left);

            cout << " " << x->key << " ";

        if (x->right) 
            inOrderTree(x->right);

}

}

void BinarySearchTree::preOrderWalk(node* x)

{

if (x != NULL)

{

          cout << " " << x->key << " ";

          if (x->left) 
              preOrderWalk(x->left);

          if (x->right) 
              preOrderWalk(x->right);

}

}

void BinarySearchTree::postOrderWalk(node* x)

{

if (x != NULL)

{

        if (x->left) postOrderWalk(x->left);

        if (x->right) postOrderWalk(x->right);

          cout << " " << x->key << " ";

}

}

int BinarySearchTree::maxValueNode(node* node)

{

          while (node->right != NULL)

          node = node->right;

          return node->key;

}

int main()
{
	system("color 02");

      BinarySearchTree bst;

      int choice, key;

                  while (true)
                  {

                              cout << endl << endl;

                              cout << " Binary Search Tree Example " << endl;

                              cout << " ----------------------------- " << endl;

                              cout << " 1. Insertion " << endl;

                              cout << " 2. In-Order Traversal " << endl;

                              cout << " 3. Pre-Order Traversal " << endl;

                              cout << " 4. Post-Order Traversal " << endl;

                              cout << " 5. Find Max (Search) " << endl;

                              cout << " 6. Exit " << endl;

                              cout << " Enter your choice : ";

                              cin >> choice;

                          switch (choice)

                          {

                            case 1: cout << " Enter key (int value) to be inserted : ";
                            	
								system("color 01");
                                cin >> key;

                                bst.treeInsert(key);

                              break;

                            case 2: cout << endl;
                            
                            	system("color 02");

                              cout << " In-Order Traversal " << endl;

                              cout << " -------------------" << endl;

                              bst.inOrderTree(bst.root);

                              break;

                            case 3: cout << endl;
                            
                            	system("color 03");

                              cout << " Pre-Order Traversal " << endl;

                              cout << " -------------------" << endl;

                              bst.preOrderWalk(bst.root);

                              break;

                            case 4: cout << endl;
                            
                            	system("color 05");

                              cout << " Post-Order Traversal " << endl;

                              cout << " -------------------" << endl;

                              bst.postOrderWalk(bst.root);

                              break;

                            case 5: cout << endl;
                            
                            	system("color 06");

                              cout << " Find Max " << endl;

                              cout << " -------------------" << endl;

                              cout<<"Max Value is: "<<bst.maxValueNode(bst.root)<<endl;

                              break;

                          case 6: 
                            system("color 07");
						  	system("pause");
						  	

                            return 0;

                            break;

                          default:

                              cout << "Invalid choice";

                          }

                  }

} 

```
