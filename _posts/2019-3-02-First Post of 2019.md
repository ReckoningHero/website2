---
layout: post
title: "Blog #5: First Post of 2019: Software Development Methodologies"
featured-img: softwaremethod

---

## First Post of 2019

![image](/assets/img/fireworks.gif)

A new year, a new software technology out of nowhere to learn! What a day to start a new year by learning what new tech is going on now and into the future!! especially in the industry where a lot of technology is being implemented each and every day regardless what kind of background you or your peers come from. In my department, software development plays a significant role in today's face paced environment especially when methodologies are chosen by the higher-ups from what method is best use for the company. In this blog, I will explain what today's startups and enterprise companies use each day to catch up in the game for software development.


## What are Software Development Methodologies and how many kind are there in the industry/market?

![image](/assets/img/627x627-SftwareDev-Feature-HUSS.jpg)

In a professional development, many developers ponder what kind of operation the team should approach in order to meet the client's expectations and needs for a particular software they desired. Lets take Apple for example! Apple has a lot of teams that operate the ecosystem of the iPhone and Mac operating system such as Mojave OS(10.14), the successor after High Sierra OS(10.13). Apple use the MVC to make an app suited for them and their customers. In this case, the project is followed by the Agile development methodology with Behavior Driven Development. What is Agile you say? Sounds like Fast? Not just fast! Agile requires a significant amount of collaborative effort to organize to promote adaptive planning, voluntary development, and continual improvement on the project given by the client. Basically, it is the methodology to adapt to change and to deal with uncertainty yet uniqueness of a particular framework by collaborative teamwork.


![image](/assets/img/APPLE_MVCcore_objects_2x.png)

## What exactly is Agile Methodology?


![image](/assets/img/AGILE-Graphic01.jpg)



Agile methods attempt to minimize risk (such as bugs, cost overruns, and changing requirements) by implementing new functionality and developing the software that are mini-increments of the new functionality. The benefit of multiple iterations is to improve efficiency by finding and fixing defects and expectation mismatches early on. The problems with this kind of methodology is the ongoing real-time communication with the client if he or she needed for a improvement on the application. It is important to make haste with time and investment on management in order to make a documentation on the software's features. Agile can be a hassle for developers, management teams, and executive organizations who are accustomed to the waterfall method, thus may have difficulty in adjusting to agile. So a hybrid approach often works well for them to deliver the software on time and sometimes later debugging if it doesn't work out for the client afterwards.

## What is the Waterfall Methodology?

![image](/assets/img/waterfall-small.jpg)




### What is your preferred methodology?















































## Binary Search Tree Code Example

As BST knowledge has enhanced over the years, there should be




```
#include <iostream>
#include <cstdlib>
#include <math.h>

using namespace std;

class BinarySearchTree
{

                private:

                class node

{

                public:

                  node* left;

                  node* right;

                  node* parent;

                  int key;

                  string data;

};

    public:

      node* root;

      BinarySearchTree()

{

        root = NULL;

}

            bool isEmpty() const { return root == NULL; }

            void inOrderTree(node*);

            void preOrderWalk(node*);

            void postOrderWalk(node*);

            void treeInsert(int );

            //void treeDeletion(int );

            int maxValueNode(node*);

};

void BinarySearchTree::treeInsert(int d)

{
                    node* z = new node();

                    z->key = d;

                    z->left = NULL;

                    z->right = NULL;

                    node* y = NULL;

                    node* x = root;

                    node* parent = NULL;

                    while (x != NULL)

                    {

                                y = x;

                                if (z->key < x->key)

                                      x = x->left;

                                else

                                      x = x->right;

                    }

                    parent = y;

                    if (y == NULL)

                            root = z;

                    else if (z->key < y->key)

                           y->left = z;

                    else

                            y->right = z;

}

void BinarySearchTree::inOrderTree(node* x)
{

if (x != NULL)
{

        if (x->left)
            inOrderTree(x->left);

            cout << " " << x->key << " ";

        if (x->right)
            inOrderTree(x->right);

}

}

void BinarySearchTree::preOrderWalk(node* x)

{

if (x != NULL)

{

          cout << " " << x->key << " ";

          if (x->left)
              preOrderWalk(x->left);

          if (x->right)
              preOrderWalk(x->right);

}

}

void BinarySearchTree::postOrderWalk(node* x)

{

if (x != NULL)

{

        if (x->left) postOrderWalk(x->left);

        if (x->right) postOrderWalk(x->right);

          cout << " " << x->key << " ";

}

}

int BinarySearchTree::maxValueNode(node* node)

{

          while (node->right != NULL)

          node = node->right;

          return node->key;

}

int main()
{
	system("color 02");

      BinarySearchTree bst;

      int choice, key;

                  while (true)
                  {

                              cout << endl << endl;

                              cout << " Binary Search Tree Example " << endl;

                              cout << " ----------------------------- " << endl;

                              cout << " 1. Insertion " << endl;

                              cout << " 2. In-Order Traversal " << endl;

                              cout << " 3. Pre-Order Traversal " << endl;

                              cout << " 4. Post-Order Traversal " << endl;

                              cout << " 5. Find Max (Search) " << endl;

                              cout << " 6. Exit " << endl;

                              cout << " Enter your choice : ";

                              cin >> choice;

                          switch (choice)

                          {

                            case 1: cout << " Enter key (int value) to be inserted : ";

								system("color 01");
                                cin >> key;

                                bst.treeInsert(key);

                              break;

                            case 2: cout << endl;

                            	system("color 02");

                              cout << " In-Order Traversal " << endl;

                              cout << " -------------------" << endl;

                              bst.inOrderTree(bst.root);

                              break;

                            case 3: cout << endl;

                            	system("color 03");

                              cout << " Pre-Order Traversal " << endl;

                              cout << " -------------------" << endl;

                              bst.preOrderWalk(bst.root);

                              break;

                            case 4: cout << endl;

                            	system("color 05");

                              cout << " Post-Order Traversal " << endl;

                              cout << " -------------------" << endl;

                              bst.postOrderWalk(bst.root);

                              break;

                            case 5: cout << endl;

                            	system("color 06");

                              cout << " Find Max " << endl;

                              cout << " -------------------" << endl;

                              cout<<"Max Value is: "<<bst.maxValueNode(bst.root)<<endl;

                              break;

                          case 6:
                            system("color 07");
						  	system("pause");


                            return 0;

                            break;

                          default:

                              cout << "Invalid choice";

                          }

                  }

}

```
